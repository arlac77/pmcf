#!/usr/bin/env node

import { writeFile, mkdir, copyFile, glob } from "node:fs/promises";
import { join } from "node:path";
import { writeLines, sectionLines } from "../src/utils.mjs";
import { prepare } from "../src/cmd.mjs";

const { world, args, options } = prepare();

const hostName = args[0];

const host = await world.host(hostName);

await generateNetworkDefs(host, options.output);
await generateMachineInfo(host, options.output);
await copySshKeys(host, options.output);
await generateKnownHosts(world.hosts(), join(options.output, "root", ".ssh"));

console.log("provides", "host", ...host.provides);
console.log("depends", `location-${host.location.name}`, ...host.depends);
console.log("replaces", `mf-${host.hostName}`, ...host.replaces);
console.log("description", `host definitions for ${host.domainName}`);
console.log("backup", "root/.ssh/known_hosts");

async function generateMachineInfo(host, dir) {
  const etcDir = join(dir, "etc");
  await writeLines(
    etcDir,
    "machine-info",
    Object.entries({
      CHASSIS: host.chassis,
      DEPLOYMENT: host.deployment,
      LOCATION: host.location.name,
      HARDWARE_VENDOR: host.vendor,
      HARDWARE_MODEL: host.modelName
    }).map(([k, v]) => `${k}=${v}`)
  );

  await writeLines(etcDir, "machine-id", [host["machine-id"]]);
  await writeLines(etcDir, "hostname", [host.hostName]);
}

async function generateNetworkDefs(host, dir) {
  const networkDir = join(dir, "etc/systemd/network");

  for (const [name, network] of Object.entries(
    host.networkInterfaces || { [host.interface || "eth0"]: host }
  )) {
    if (name !== "eth0" && network.hwaddr) {
      await writeLines(networkDir, `${name}.link`, [
        sectionLines("Match", { MACAddress: network.hwaddr }),
        "",
        sectionLines("Link", { Name: name })
      ]);
    }

    const networkSections = [
      sectionLines("Match", { Name: name }),
      "",
      sectionLines("Address", {
        Address: network.ipv4 + "/" + network.network.ipv4_netmask
      })
    ];

    if (network["link-local-ipv6"]) {
      networkSections.push(
        "",
        sectionLines("Address", {
          Address: network["link-local-ipv6"]
        })
      );
    }

    switch (network?.network?.kind) {
      case "ethernet":
      case "wifi":
        const routeSectionExtra = network?.destination
          ? { Destination: network.destination }
          : { Gateway: host.location.gateway_ipv4 };

        const networkSectionExtra = network.arpbridge
          ? {
              IPForward: "yes",
              IPv4ProxyARP: "yes"
            }
          : {};

        networkSections.push(
          "",
          sectionLines("Network", {
            ...networkSectionExtra,
            DHCP: "no",
            DHCPServer: "no",
            MulticastDNS: "yes",
            LinkLocalAddressing: "ipv6",
            IPv6LinkLocalAddressGenerationMode: "stable-privacy"
          }),
          "",
          sectionLines("Route", {
            ...routeSectionExtra,
            Scope: network.scope,
            Metric: network.metric,
            InitialCongestionWindow: 20,
            InitialAdvertisedReceiveWindow: 20
          }),
          "",
          sectionLines("IPv6AcceptRA", {
            UseAutonomousPrefix: "true",
            UseOnLinkPrefix: "true",
            DHCPv6Client: "false",
            Token: "eui64"
          })
        );

        if (network.arpbridge) {
          networkSections.push(
            "",
            sectionLines("Link", { Promiscuous: "yes" })
          );
        }
    }

    await writeLines(networkDir, `${name}.network`, networkSections);

    switch (network?.network?.kind) {
      case "wireguard":
        {
        }
        break;
      case "wifi": {
        const d = join(dir, "etc/wpa_supplicant");
        await mkdir(d, { recursive: true });
        writeFile(
          join(d, `wpa_supplicant-${name}.conf`),
          `country=${host.location.country}
ctrl_interface=DIR=/run/wpa_supplicant GROUP=netdev
update_config=1
p2p_disabled=1
network={
  ssid="${network.ssid}"
  psk=${network.psk}
  scan_ssid=1
}`,
          "utf8"
        );

        host.postinstall.push(
          `systemctl enable wpa_supplicant@${name}.service`
        );
      }
    }
  }
}

async function copySshKeys(host, dir) {
  const sshDir = join(dir, "etc", "ssh");

  await mkdir(sshDir, { recursive: true });

  for await (const file of glob("ssh_host_*", { cwd: host.directory })) {
    copyFile(join(host.directory, file), join(sshDir, file));
  }
}

async function generateKnownHosts(hosts, dir) {
  const keys = [];
  for await (const host of hosts) {
    try {
      const [alg, key, desc] = (await host.publicKey("ed25519")).split(/\s+/);
      keys.push(`${host.domainName} ${alg} ${key}`);

      for await (const addr of host.networkAddresses()) {
        keys.push(`${addr.address} ${alg} ${key}`);
      }
    } catch {}
  }

  await writeLines(dir, "known_hosts", keys);
}
