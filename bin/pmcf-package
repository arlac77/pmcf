#!/usr/bin/env node

import { join } from "node:path";
import { readFile, mkdtemp } from "node:fs/promises";
import { tmpdir } from "node:os";
import { env } from "node:process";
import { packageDirectory } from "pkg-dir";
import { FileContentProvider, createPublishingDetails } from "npm-pkgbuild";
import { prepare } from "../src/cmd.mjs";
import { asArray } from "../src/utils.mjs";

const { root, args, options } = await prepare();

if (!options.output) {
  options.output = await mkdtemp(join(tmpdir(), "pmcf"));
}

const pkgDir = await packageDirectory({ cwd: options.root });
const pkg = JSON.parse(await readFile(join(pkgDir, "package.json"), "utf8"));
const publishingDetails = createPublishingDetails(asArray(options.publish), env);

console.log(env);
console.log(publishingDetails);
for (const name of args) {
  const object = await root.load(name);
  const stagingDir = join(options.output, object.fullName);

  for await (const { properties, outputs } of object.preparePackages(
    stagingDir
  )) {
    for (const outputFactory of outputs) {
      properties.version = pkg.version;
      properties.license = pkg.license;
      properties.maintainer = pkg.contributors.map(
        c => c.name + (c.email ? ` <${c.email}>` : "")
      );

      console.log(properties.name);
      if (properties.verbose) {
        console.log(properties);
      }

      const sources = [
        new FileContentProvider(stagingDir + "/")[Symbol.asyncIterator]()
      ];

      const output = new outputFactory(properties);

      const artifact = await output.create(
        sources,
        [],
        publishingDetails,
        options
      );

      if (properties.verbose) {
        console.log(artifact);
      }

      await Promise.all(
        publishingDetails.map(publishDetail =>
          output.publish(artifact, publishDetail)
        )
      );
    }
  }
}
