#!/usr/bin/env node

import { join } from "node:path";
import { createHmac } from "node:crypto";
import { writeLines, isIPv4Address } from "../src/utils.mjs";
import { prepare } from "../src/cmd.mjs";

const { world, args, options } = prepare();

const owner = await world.load(args[0]);
const updates = [
  Math.ceil(Date.now() / 1000),
  36000,
  72000,
  600000,
  60000
].join(" ");

const NAME_LEN = 35;

await generateNamedDefs(owner, options.output);

console.log("depends", "mf-named");
console.log("replaces", "mf-named-zones");
console.log("description", `named defintions for ${owner.name}`);

async function generateNamedDefs(owner, targetDir) {
  const dns = owner.dns;
  const ttl = dns.recordTTL;

  for (const domain of dns.domains) {
    const zones = [];
    const records = new Set();

    const nameserver = (await owner.service({ type: "dns" }))?.owner;
    const rname = dns.administratorEmail.replace(/@/, ".");

    const createRecord = (key, type, value) => {
      return {
        key,
        type,
        value,
        toString: () =>
          `${key.padEnd(NAME_LEN, " ")} ${ttl} IN ${type} ${value}`
      };
    };

    for await (const mail of owner.services({ type: "smtp" })) {
      records.add(
        createRecord("@", "MX", `${mail.priority} ${mail.owner.domainName}.`)
      );
    }

    console.log(owner.name, domain, nameserver?.hostName, rname);

    const SOARecord = createRecord(
      "@",
      "SOA",
      `${nameserver?.domainName}. ${rname}. (${updates})`
    );

    const NSRecord = createRecord("@", "NS", `${nameserver?.ipAddress}.`);

    const catalogZone = {
      id: `catalog.${domain}`,
      file: `catalog.${domain}.zone`,
      records: new Set([
        SOARecord,
        NSRecord,
        createRecord(`version.${domain}.`, "TXT", '"2"')
      ])
    };

    const zone = {
      id: domain,
      file: `${domain}.zone`,
      records: new Set([SOARecord, NSRecord, ...records])
    };
    zones.push(zone);

    for (const subnet of owner.subnets()) {
      if (subnet.address) {
        const reverse = reverseAddress(subnet.address);
        const reverseArpa = reverseArpaAddress(subnet.address);
        const zone = {
          id: reverseArpa,
          file: `${reverse}.zone`,
          records: new Set([SOARecord, NSRecord])
        };
        zones.push(zone);
        subnet.reverseZone = zone;
      }
    }

    for await (const {
      address,
      networkInterface
    } of owner.networkAddresses()) {
      const host = networkInterface.host;
      zone.records.add(
        createRecord(
          host.hostName,
          isIPv4Address(address) ? "A   " : "AAAA",
          normalizeIPAddress(address)
        )
      );

      for (const service of host.services()) {
        if (service.master && service.alias) {
          zone.records.add(
            createRecord(service.alias, "CNAME", `${host.domainName}.`)
          );
        }

        if (service.srvPrefix) {
          zone.records.add(
            createRecord(
              `${service.srvPrefix}.${host.domainName}.`,
              "SRV",
              `${String(service.priority).padStart(4)} ${String(
                service.weight
              ).padStart(3)} ${String(service.port).padStart(5)} ${
                host.domainName
              }.`
            )
          );
        }
      }

      const reverseZone = networkInterface.network.subnet?.reverseZone;

      if (reverseZone && isIPv4Address(address)) {
        reverseZone.records.add(
          createRecord(
            reverseArpaAddress(address) + ".",
            "PTR",
            `${networkInterface.host.domainName}.`
          )
        );
      }
    }

    const zoneConfig = [];

    zones.push(catalogZone);

    for (const zone of zones) {
      if (zone !== catalogZone) {
        const hash = createHmac("md5", zone.id).digest("hex");
        catalogZone.records.add(
          `${hash}.zones.${domain}. IN PTR   ${zone.id}.`
        );
      }

      zoneConfig.push(`zone \"${zone.id}\" {`);
      zoneConfig.push(`  type master;`);
      zoneConfig.push(`  file \"${zone.file}\";`);

      zoneConfig.push(
        `  allow-update { ${
          dns.allowedUpdates.length ? dns.allowedUpdates.join(";") : "none"
        }; };`
      );
      zoneConfig.push(`  notify yes;`);
      zoneConfig.push(`};`);
      zoneConfig.push("");

      writeLines(join(targetDir, "var/lib/named"), zone.file, zone.records);
    }

    writeLines(
      join(targetDir, "etc/named.d/zones"),
      `${domain}.zone.conf`,
      zoneConfig
    );
  }
}

export function reverseAddress(address) {
  if (isIPv4Address(address)) {
    return address.split(".").reverse().join(".");
  }

  return normalizeIPAddress(address)
    .replaceAll(":", "")
    .split("")
    .reverse()
    .join(".");
}

export function reverseArpaAddress(address) {
  return (
    reverseAddress(address) +
    (isIPv4Address(address) ? ".in-addr.arpa" : ".ip6.arpa")
  );
}

export function normalizeIPAddress(address) {
  if (isIPv4Address(address)) {
    return address;
  }
  address = address.replace(/\/\d+$/, "");
  const parts = address.split(":");
  const i = parts.indexOf("");
  if (i >= 0) {
    parts.splice(i, 1, ..."0".repeat(9 - parts.length));
  }
  return parts.map(s => s.padStart(4, "0")).join(":");
}
