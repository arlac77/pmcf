#!/usr/bin/env node

import { join } from "node:path";
import { createHmac } from "node:crypto";
import {
  writeLines,
  isIPv4Address,
  normalizeIPAddress
} from "../src/utils.mjs";
import { prepare } from "../src/cmd.mjs";

const { root, args, options } = await prepare();

const owner = await root.load(args[0]);

await generateNamedDefs(owner, options.output);

console.log("depends", "mf-named");
console.log("replaces", "mf-named-zones");
console.log("description", `named defintions for ${owner.name}`);

async function generateNamedDefs(owner, targetDir) {
  const dns = owner.dns;
  const ttl = dns.recordTTL;
  const updates = [Math.ceil(Date.now() / 1000), ...dns.soaUpdates].join(" ");

  for (const domain of dns.domains) {
    const zones = [];
    const records = new Set();

    const nameserver = (await owner.service({ type: "dns" }))?.owner;
    const rname = dns.administratorEmail.replace(/@/, ".");

    let maxKeyLength;

    const createRecord = (key, type, value) => {
      return {
        key,
        toString: () =>
          `${key.padEnd(maxKeyLength, " ")} ${ttl} IN ${type.padEnd(
            5,
            " "
          )} ${value}`
      };
    };

    for await (const mail of owner.services({ type: "smtp" })) {
      records.add(
        createRecord("@", "MX", `${mail.priority} ${mail.owner.domainName}.`)
      );
    }

    console.log(owner.name, domain, nameserver?.hostName, rname);

    const SOARecord = createRecord(
      "@",
      "SOA",
      `${nameserver?.domainName}. ${rname}. (${updates})`
    );

    const NSRecord = createRecord("@", "NS", `${nameserver?.ipAddress}.`);

    const catalogZone = {
      id: `catalog.${domain}`,
      file: `catalog.${domain}.zone`,
      records: new Set([
        SOARecord,
        NSRecord,
        createRecord(`version.${domain}.`, "TXT", '"2"')
      ])
    };

    const zone = {
      id: domain,
      file: `${domain}.zone`,
      records: new Set([SOARecord, NSRecord, ...records])
    };
    zones.push(zone);

    for (const subnet of owner.subnets()) {
      if (subnet.address) {
        const reverse = reverseAddress(subnet.address);
        const reverseArpa = reverseArpaAddress(subnet.address);
        const zone = {
          id: reverseArpa,
          file: `${reverse}.zone`,
          records: new Set([SOARecord, NSRecord])
        };
        zones.push(zone);
        subnet.reverseZone = zone;
      }
    }

    const hosts = new Set();

    for await (const {
      address,
      networkInterface
    } of owner.networkAddresses()) {
      const host = networkInterface.host;
      zone.records.add(
        createRecord(
          host.domainName + ".",
          isIPv4Address(address) ? "A   " : "AAAA",
          normalizeIPAddress(address)
        )
      );

      if (!hosts.has(host)) {
        hosts.add(host);
        for (const service of host.services()) {
          //console.log(service.name);
          if (service.master && service.alias) {
            zone.records.add(
              createRecord(service.alias, "CNAME", `${host.domainName}.`)
            );
          }

          if (dns.srvRecords && service.srvPrefix) {
            zone.records.add(
              createRecord(
                `${service.srvPrefix}.${host.domainName}.`,
                "SRV",
                `${String(service.priority).padStart(4)} ${String(
                  service.weight
                ).padStart(3)} ${String(service.port).padStart(5)} ${
                  host.domainName
                }.`
              )
            );
          }
        }
      }

      const reverseZone = networkInterface.network.subnet?.reverseZone;

      if (reverseZone && isIPv4Address(address)) {
        reverseZone.records.add(
          createRecord(
            reverseArpaAddress(address) + ".",
            "PTR",
            `${networkInterface.host.domainName}.`
          )
        );
      }
    }

    const zoneConfig = [];

    zones.push(catalogZone);

    for (const zone of zones) {
      if (zone !== catalogZone) {
        const hash = createHmac("md5", zone.id).digest("hex");
        catalogZone.records.add(
          createRecord(`${hash}.zones.${domain}.`, "PTR", `${zone.id}.`)
        );
      }

      zoneConfig.push(`zone \"${zone.id}\" {`);
      zoneConfig.push(`  type master;`);
      zoneConfig.push(`  file \"${zone.file}\";`);

      zoneConfig.push(
        `  allow-update { ${
          dns.allowedUpdates.length ? dns.allowedUpdates.join(";") : "none"
        }; };`
      );
      zoneConfig.push(`  notify yes;`);
      zoneConfig.push(`};`);
      zoneConfig.push("");

      maxKeyLength = 0;
      for (const r of zone.records) {
        if (r.key.length > maxKeyLength) {
          maxKeyLength = r.key.length;
        }
      }

      writeLines(join(targetDir, "var/lib/named"), zone.file, zone.records);
    }

    writeLines(
      join(targetDir, "etc/named.d/zones"),
      `${domain}.zone.conf`,
      zoneConfig
    );
  }
}

export function reverseAddress(address) {
  if (isIPv4Address(address)) {
    return address.split(".").reverse().join(".");
  }

  return normalizeIPAddress(address)
    .replaceAll(":", "")
    .split("")
    .reverse()
    .join(".");
}

export function reverseArpaAddress(address) {
  return (
    reverseAddress(address) +
    (isIPv4Address(address) ? ".in-addr.arpa" : ".ip6.arpa")
  );
}
